# GPIO驱动编程

## IMX6ULL GPIO编程

### GPIO模块资源说明

参考资料：芯片手册《Chapter 26 : General Purpose Input/Output (GPIO)》

一共5组GPIO，每组最多32个，实际上每组可能没有这么多可用的。

GPIO1 有 32 个引脚： GPIO1_IO0~GPIO1_IO31
GPIO2 有 22 个引脚： GPIO2_IO0~GPIO2_IO21
GPIO3 有 29 个引脚： GPIO3_IO0~GPIO3_IO28
GPIO4 有 29 个引脚： GPIO4_IO0~GPIO4_IO28
GPIO5 有 12 个引脚： GPIO5_IO0~GPIO5_IO11

控制GPIO模块分为3大模块：CCM 、 IOMUXC 、 GPIO模块本身；

- CCM：设置GPIO模块时钟使能；

- IOMUXC ：复用功能选择；
- GPIO：设置输入输出上下拉等功能。

所以要想使用GPIO，需要三步：

- 通过CCM模块设置GPIOx时钟使能
- 通过IOMUXC：选择GPIOx引脚的复用功能，以及上下拉等功能
- 通过GPIO模块本身，设置输入输出，读取或者设置输出高低电平

![](media/image-20200528112439356.png)

### 使能GPIO模块的时钟

CCM可以用来设置是否使能GPIO模块的时钟，通过设置CCM_CCGRy寄存器中的2位来决定GPIOx模块的时钟是否使能。

![image-20200528111936917](media/image-20200528111936917.png)

| 值   | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| 00   | 一直关闭时钟                                                 |
| 01   | 该GPIO 模块在 CPU run mode 情况下是使能的；在 WAIT 或 STOP 模式下，关闭 |
| 10   | 保留                                                         |
| 11   | 一直使能时钟                                                 |

- **GPIO2**模块的时钟使能有**CCM_CCGR0**寄存器的位决定

![](media/image-20200528112406457.png)

- **GPIO1-5**模块的时钟使能有**CCM_CCGR1**寄存器决定

![](media/image-20200528112545064.png)

**GPIO3**模块的时钟使能有**CCM_CCGR2**寄存器决定

![](media/image-20200528112632155.png)

**GPIO4**模块的时钟使能有**CCM_CCGR2**寄存器决定

![](media/image-20200528112705015.png)



 ### 选择复用功能

IOMUXC模块可以设置引脚的模式 Mode 、功能。参考资料：芯片手册《Chapter 3 2 : IOMUX Controller (IOMU XC) 》

对于某个某组引脚， IOMUXC 中有 2 个寄存器用来设置它：

- IOMUXC_SW_MUX…… ：设置复用功能

- IOMUXC_SW_PAD……：设置上下拉等参数

#### 选择复用功能

IOMUXC_SW_MUX_CTL_PAD_x ：某个引脚的功能寄存器
IOMUXC_SW_MUX_CTL_GRP_<GROUP NAME>：某组引脚的功能寄存器
无论是某个引脚，或是某组预设的引脚，都有8 个可选的模式 alternate (ALT) MUX_MODE。

例如GPIO1_IO00引脚，当把IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO00寄存器的MUX_MODE(bit【0-3】)的位设置为0101(ALT5) 时，GPIO1_IO00引脚被设置为了GPIO功能。

![](media/image-20200528114526303.png)

![](media/image-20200528133554270.png)

#### 设置上下拉电阻等参数

**IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO00** 寄存器是设置GPIO1_IO00引脚的上下拉等参数的。其他的引脚也是类似，看数据手册即可。

![](media/image-20200528135713459.png)

### GPIO模块输入输出设置

内部框图如下：

![](media/image-20200528140303517.png)

只关心三个寄存器：

- GPIOx_GDIR ：设置引脚方向，每位对应一个引脚 1 output 0 input

  ![](media/image-20200528140504162.png)

- GPIOx_GDIR ：设置输出引脚的电平，每位对应一个引脚 1 高电平， 0 低电平

  ![](media/image-20200528140544881.png)

- GPIOx_PSR ：读取引脚的电平，每位对应一个引脚 1 高电平， 0 低电平

  ![](media/image-20200528140603236.png)

### 编程步骤

#### 读GPIO引脚

① 设置CCM_CCGRx寄存器中某位使能对应的GPIO模块 // 默认是使能的，上图省略了
② 设置IOMUX来选择引脚用于GPIO
③ 设置GPIOx_GDIR中某位为0，把该引脚设置为输入功能
④ 读GPIOx_DR或GPIOx_PSR得到某位的值（读GPIOx_DR返回的是GPIOx_PSR的值）

#### 写GPIO引脚

① 设置CCM_CCGRx寄存器中某位使能对应的GPIO模块 // 默认是使能的，上图省略了
② 设置IOMUX来选择引脚用于GPIO
③ 设置GPIOx_GDIR中某位为1，把该引脚设置为输出功能
④ 写GPIOx_DR某位的值

需要注意的是，你可以设置该引脚的loopback功能，这样就可以从GPIOx_PSR中读到引脚的有实电平；你从GPIOx_DR中读回的只是上次设置的值，它并不能反应引脚的真实电平，比如可能因为硬件故障导致该引脚跟地短路了，你通过设置GPIOx_DR让它输出高电平并不会起效果。



## RK3288 GPIO编程

### GPIO模块资源说明

一共9组（GPIO0-GPIO8)，每组又分为四个小组port A、B、C、D，每个小组最多8个IO，所以理论上一组GPIO最多32个，实际上每组可能没有这么多可用的。比如 GPIO0 只有 GPIO0_A0 -A7 、 GPIO0_B0-B7 、 GPIO0_C0
-C2 这些引脚。

RK3288 GPIO模块框图

![image-20200528144426090](media/image-20200528144426090.png)



 GPIO的控制涉及 4 大模块： CRU 、 PMU 、 GRF 、 GPIO 模块本身

- CRU ：用于设置是否向 GPIO 模块提供时钟；
- PMU ：
- GRF ：
- GPIO ：

所以要想使用GPIO就得有以下步骤：

- 



### 使能GPIO 时钟

CRU 用于设置是否向 GPIO 模块提供时钟：内部框图如下：

![](media/image-20200528143100621.png)

可以设置寄存器使能GPIOx 的时钟：

- CRU_CLKGATE17_CON用于控制 GPIO0
- CRU_CLKGATE14_CON用于控制 GPIO1-8

### PMU控制电源：

电源管理单元里，有多个电源域(power domain ，简称为 PM)，在一个域下有多个设备。
比如PD_ALIVE ，它下面有这些设备 CRU 、 GRF 、 GPIO 1~8 、 TIMER 或 WDT 。
比如PD_PMU ，它下面有这些设备 PMU 、 SRAM(4K) 、 Secure GRF 、 GPIO0 。
可见，GPIO0 、 GPIO1~8 分属不同的 PMU 。GPIO0、 GPIO1~8 都是常供电的 ，它们是否工作取决于其时钟是否使能。

### 设置引脚的模式 (Mode 、功能GPIO0）

GPIO0比较特殊，为了让其引脚用于 GPIO 功能，要设置 PMU 里的相关寄存器。
GPIO1-8 类似，为了让其引脚用于 GPIO 功能，要设置 GRF 里的相关寄存器。

### GPIO模块内部

方向：引脚设置为GPIO 时，可以继续设置寄存器 GPIO_SWPORTA_DDR 确定它是输出引脚，还是输入引
脚。
数值：对于输出引脚，可以设置寄存器GPIO_SWPORTA_DR 让它输出高、低电平
对于输入引脚，可以读取寄存器 GPIO_EXT_PORTA 得到引脚的当前电平 。

### RK3288相关寄存器偏移地址



![](media/image-20200528144139260.png)

## 字符设备驱动

### Linux设备号
#### 设备号组成
Linux提供`dev_t`的数据类型表示设备号：高12位主设备号(大小:0-4095)，低20位位次设备号
```c
include/linux/types.h
    
typedef __u32 __kernel_dev_t;
typedef __kernel_dev_t dev_t; // 所以可以看出dev_t就是一个uint32_t 的数据

```

#### 设备号常用函数

```c
include/linux/kdev_t.h

#define MINORBITS 20 
#define MINORMASK ((1U << MINORBITS) - 1) 

#define MAJOR(dev) ((unsigned int) ((dev) >> MINORBITS)) // 从设备号中得到主设备号
#define MINOR(dev) ((unsigned int) ((dev) & MINORMASK))  // 从设备号中得到次设备号
#define MKDEV(ma,mi) (((ma) << MINORBITS) | (mi))        // 把主设备号和次设备号组装成dev_t类型的linux设备号
```
### 注册字符设备并确定设备号

#### linux用cdev表示一个字符设备

```c
struct cdev { 
	struct kobject kobj; 
	struct module *owner; 
	const struct file_operations *ops;   // 操作函数集合
	struct list_head list; 
	dev_t dev;                           // 设备id
	unsigned int count; 
};

```

#### 入口函数中定义字符设备步骤如下

```c
struct cdev testcdev;            	// 定义字符设备结构体 
testcdev.owner = THIS_MODULE;     
cdev_init(&testcdev, &test_fops);	// 字符设备结构体 初始化
cdev_add(&testcdev, devid, 1);   	// 把字符设备添加到linux内核中
```

#### 出口函数删除字符设备


```C
cdev_del(&testcdev);
```

#### 函数原型介绍

```c
/**
*
*@cdev：字符设备
*@fops：file_operations结构体指针
*/
void cdev_init(struct cdev *cdev, const struct file_operations *fops)

/**
*用于向 Linux系统添加字符设备 (cdev结构体变量 )
*@p：指向要往系统添加的字符设备
*@count：要添加的设备数量
*/
int cdev_add(struct cdev *p, dev_t dev, unsigned count)

/**
*驱动卸载的时候要从linux内核中卸载字符设备
*@p：指向要往系统添加的字符设备
*/
void cdev_del(struct cdev *p)
```



 在 2.4 的内核我们使用 `major = register_chrdev(0, "xym_led", &led_drv)` 来进行字符设备注册，在注册过程中分配了设备号，这种方式每一个主设备号只能存放一种设备，它们使用相同的 `file_operation` 结构体，也就是说内核最多支持 256 个字符设备驱动程序。

在 2.6 的内核之后，新增了一个 register_chrdev_region 函数，它支持将同一个主设备号下的次设备号进行分段，每一段供给一个字符设备驱动程序使用，使得资源利用率大大提升，同时，2.6 的内核以后保留了原有register_chrdev 方法。在 2.6 的内核中这两种方法都会调用到 __register_chrdev_region 函数进行设备节点的分配。

```c
1：老版本的内核在入口函数都是使用register_chrdev函数来确定主设备号
major = register_chrdev(0, "xym_led", &led_drv); // 第一个参数是0的话表示自动申请设备号
调用关系
register_chrdev
	-》__register_chrdev(major, 0, 256, name, fops)
		-》__register_chrdev_region(major, baseminor, count, name)
		-》cdev = cdev_alloc();
		-》cdev_add
 从上面的调用关系可以看出，register_chrdev不仅仅完成了设备号的申请，还完成了字符设备cdev的创建和添加到内核工作
2：新版本在入口函数中使用register_chrdev_region或者alloc_chrdev_region函数获取主设备号
   if(major){
	    devid = MKDEV(major, 0); 
		register_chrdev_region(devid, 1, "xym_led");  /* 设备号事先确定的情况 */
	}else{
		alloc_chrdev_region(&devid, 0, 1, "xym_led"); /* 设备号事先不确定，申请设备号 */ 
		major = MAJOR(devid); 					      /* 获取主设备号 */ 
		minor = MINOR(devid); 					       /* 获取次设备号 */
	}
   /* 这里 需要手动创建字符设备，并添加到内核 */
	struct cdev cdev;
    cdev.owner = THIS_MODULE;
	cdev_init(&cdev, &led_drv);
    cdev_add(&cdev, devid, 1);

调用关系 1
    register_chrdev_region
    	-》__register_chrdev_region(MAJOR(n), MINOR(n)，next - n, name);
                                   
调用关系 2
	alloc_chrdev_region
    	-》__register_chrdev_region(0, baseminor, count, name);
                                   
从调用关系可以看出无论是新版本还是老版本，获取设备号的方式，最总都是 __register_chrdev_region函数实现，只是老版本register_chrdev不仅仅会分配设备号，还创建了并向内核添加了字符设备cdev

老版本用到函数，原型如下：
/**
* 设备号释放函数
*@major ：主设备号，如果为0，那么系统默认会自动获取主设备号返回
*@name：设备名字
*@fops: 驱动的 file_operations函数集合
*/
include/linux/fs.h
static inline int register_chrdev(unsigned int major, const char *name,
				  const struct file_operations *fops)
{
    /*
    * 这个地方就是我们说的为什么使用register_chrdev函数获取设备号的时候次设备号一下子就没了，这里从0开     * 始，申请了256个次设备号,就是一个主设备号major号下的256个次设备号(0-255)全用完了
    */
	return __register_chrdev(major, 0, 256, name, fops); 
	
}

int __register_chrdev(unsigned int major, unsigned int baseminor,
		      unsigned int count, const char *name,
		      const struct file_operations *fops)
{
	struct char_device_struct *cd;
	struct cdev *cdev;
 
	cd = __register_chrdev_region(major, baseminor, count, name);// 申请设备号
	cdev = cdev_alloc();                                         // 创建cdev
	cdev->owner = fops->owner;
	cdev->ops = fops;
	kobject_set_name(&cdev->kobj, "%s", name);

	err = cdev_add(cdev, MKDEV(cd->major, baseminor), count);     // 增加cdev到内核
	
	cd->cdev = cdev;

	return major ? 0 : cd->major;
   ………………… 
   
}

释放字符设备函数
/**
* 设备号释放函数
*@major ：主设备号，如果为0，那么系统默认会自动获取主设备号返回
*@name：设备名字
*/
static inline void unregister_chrdev(unsigned int major, const char *name)




新版本用到函数，原型如下：
    
1：如果设备号已经确定，那么使用 register_chrdev_region 函数 申请设备id
/**
* 需要在驱动的入口函数申请设备号
*@from		：要从哪个设备id开始申请设备号
*@count		：要申请的设备号数量。
*@name		：设备名字
*/
int register_chrdev_region(dev_t from, unsigned count, const char *name)

2：如果主设备号没有确定 使用alloc_chrdev_region函数申请设备id
/**
* 需要在驱动的入口函数申请设备号
*@dev		：保存申请到的设备号
*@baseminor	：次设备号起始地址,可以申请一段连续的多个设备号，这些设备号的主设备号一样，但是次设备号不同，次设备号以 baseminor为起始地址地址开始递增。一般从0，也就是说次设备号从0开始。
*@count		：要申请的设备号数量。
*@name		：设备名字
*/
int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)

3：字符设备释放函数，无论是register_chrdev_region或者alloc_chrdev_region注册的字符设备，都用该函数进行释放
/**
* 设备号释放函数，在出口函数中调用，无
*@from ：要释放的设备号。
*@count：表示从 from开始，要释放的设备号数量
*/
void unregister_chrdev_region(dev_t from, unsigned count)
```

**注意**：使用`cat /proc/devices` 命令查看当前系统已经使用的了设备号

### 设备节点

##### 命令行手动创建设备节点
```bash
/dev/chrdevbase ：设备节点名字
c 	:代表字符设备驱动
200	: 主设备号
0	： 次设备号

mknod /dev/chrdevbase c 200 0
```

##### 自动创建设备节点
在驱动入口函数中先创建类，然后在类下创建设备

```
/* 创建类，类名 xym_led_class*/
led_class = class_create(THIS_MODULE, "xym_led_class");    
/* 类下创建设备，那么 /dev/xym_led 即是显示的设备节点*/
device_create(led_class, NULL, devid, NULL, "xym_led");     
```

在出口函数就要设备类和设备节点

```c
  device_destroy(led_class, devid);  // 摧毁类下的设备
  class_destroy(led_class);          // 摧毁类
```



##### 创建类和删除类函数原型

自动创建设备节点相关代码。首先要创建一个 class类， class是个结构体，定义在文件
include/linux/device.h里面。 class_create是类创建函数， class_create是个宏定义，内容如下：

```

/**
*
*@owner：THIS_MODULE
*@name：类名
*/

#define class_create(owner, name) \ 
({ \ 
	static struct lock_class_key __key; \ 
    __class_create(owner, name, &__key); \ 
}) 


struct class *__class_create(struct module *owner, const char *name, 8 struct lock_class_key *key)

/**
*
*@cls：指向要卸载的类指针
*/
void class_destroy(struct class *cls);
```

##### 创建设备

```
/**
*
*@class：指向要在哪个类下面创建设备的类指针
*@parent：父亲，一般为NULL
*@devt  : 设备id
*@drvdata:设备可能会使用的一些数据
*@fmt ：可变参数，设备名字，该名字会在/dev/目录下显示
*/
建好类以后还不能实现自动创建设备节点，我们还需要在这个类下创建一个设备。使用 device_create函数在类下面创建设备， device_create函 数原型如下：

struct device *device_create(struct class *class, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...)
```

在设备卸载的时候，即出口函数中调用摧毁函数
参数 classs是要删除的设备所处的类，参数 devt是要删除的设备号。

```
/**
*
*@class：指向要删除的设备所处的类
*@devt  : 设备id
*/
void device_destroy(struct class *class, dev_t devt)
```



### mmu地址映射
![](media/image-20200601095304812.png)
- 完成虚拟空间到物理空间的映射。
- 内存保护，设置存储器的访问权限，设置虚拟存储空间的缓冲特性。

#### `ioremap`

Linux内核启动的时候会初始化MMU，设置好内存映射，设置好以后CPU访问的都是虚
拟地址。当我们想访问物理地址的时候就必须做相应的转换`ioremap`函数。

`ioremap`函数用于获取指定物理地址空间对应的虚拟地址空间，定义在
`arch/arm/include/asm/io.h`文件中，定义如下：

```c
/**
*@phys_addr	：要映射给的物理起始地址。
*@*@size		：要映射的内存空间大小。
mtype ioremap的类型，可以选择 MT_DEVICE、 MT_DEVICE_NONSHARED、MT_DEVICE_CACHED和 *@MT_DEVICE_WC ioremap函数选择 MT_DEVICE。
*返回值		：  __iomem类型的指针，指向映射后的虚拟空间首地址。
*/
#define ioremap(cookie,size) __arm_ioremap((cookie), (size), MT_DEVICE) 
void __iomem * __arm_ioremap(phys_addr_t phys_addr, size_t size, unsigned int mtype) 
{ 
	return arch_ioremap_caller(phys_addr, size, mtype, __builtin_return_address(0)); 
}
```

例如我们要访问GPIO1_IO03的寄存器，可以这样定义

```c
#define SW_MUX_GPIO1_IO03_BASE (0X020E0068)            // 查找手册确定要操作的寄存器物理地址
static void __iomem* SW_MUX_GPIO1_IO03; 
SW_MUX_GPIO1_IO03 = ioremap(SW_MUX_GPIO1_IO03_BASE, 4);// 通过ioremap把物理地址转换为虚拟地址 SW_MUX_GPIO1_IO03 这样就可以用SW_MUX_GPIO1_IO03访问了
```

#### iounmap函数

卸载驱动的时候需要使用 iounmap函数释放掉 ioremap函数所做的映射， iounmap函数原
型如下：

```
函数原型 void iounmap (volatile void __iomem *addr)
iounmap(SW_MUX_GPIO1_IO03);
```

##### 内核空间的内存操作函数

使用 ioremap函数将寄存器的物理地址映射到虚拟地址以后，我们就可以直接通过指针访问这些地址，但是 Linux内核不建议这么做，而是推荐使用一组操作函数来对映射后的内存进行读写操作。

###### 读操作函数

```
u8 readb(const volatile void __iomem *addr) 
u16 readw(const volatile void __iomem *addr) 
u32 readl(const volatile void __iomem *addr)
```

readb、 readw和 readl这三个函数分别对应 8bit、 16bit和 32bit读操作，参数 addr就是要
读取写内存地址，返回值就是读取到的数据。

###### 写操作函数

写操作函数有如下几个：

```
void writeb(u8 value, volatile void __iomem *addr) 
void writew(u16 value, volatile void __iomem *addr) 
void writel(u32 value, volatile void __iomem *addr)
```

writeb、 writew和 writel这三个函数分别对应 8bit、 16bit和 32bit写操作，参数 value是要
写入的数值， addr是要写入的地址。

### printf 和printk

printf运行在用户空间，printk运行在内核空间，可以根据日志级别对消息进行分类，一共有 8个消息级别，
这 8个消息级别定义在文件 include/linux/kern_levels.h里面，定 义如下：

```c
#define KERN_SOH "\001" 
#define KERN_EMERG KERN_SOH "0" /* 紧急事件，一般是内核崩溃 */ 
#define KERN_ALERT KERN_SOH "1" /* 必 须立即采取行动 */ 
#define KERN_CRIT KERN_SOH "2" /* 临界条件，比如严重的软件或硬件错误 */ 
#define KERN_ERR KERN_SOH "3" /* 错误状态，一般设备驱动程序中使用KERN_ERR报告硬件错误 */ 
#define KERN_WARNING KERN_SOH "4" /* 警告信息，不会对系统造成严重影响 */ 
#define KERN_NOTICE KERN_SOH "5" /* 有必要进行提示的一些信息 */ 
#define KERN_INFO KERN_SOH "6" /* 提示性的信息 */ 
#define KERN_DEBUG KERN_SOH "7" /* 调试信息 */ 一共定义了 8个级别，其中 0的优先级最高， 7的优先级最低。
```

如果要设置消息级别，参考如下示例：

```
printk(KERN_EMERG "gsmi: Log Shutdown Reason\n");
```

不显式的设置消息级别，那么 printk将会采用默认级别

```c
MESSAGE_LOGLEVEL_DEFAULT默认为 4。
在 include/linux/printk.h中有个宏 
#define CONSOLE_LOGLEVEL_DEFAULT 7 
```

消息基本高于7的才会被显示出来

































